//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Salton/Documents/Projects/xstream/xstream/src/java/com/thoughtworks/xstream/io/xml/SaxWriter.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComThoughtworksXstreamIoXmlSaxWriter")
#ifdef RESTRICT_ComThoughtworksXstreamIoXmlSaxWriter
#define INCLUDE_ALL_ComThoughtworksXstreamIoXmlSaxWriter 0
#else
#define INCLUDE_ALL_ComThoughtworksXstreamIoXmlSaxWriter 1
#endif
#undef RESTRICT_ComThoughtworksXstreamIoXmlSaxWriter

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComThoughtworksXstreamIoXmlSaxWriter_) && (INCLUDE_ALL_ComThoughtworksXstreamIoXmlSaxWriter || defined(INCLUDE_ComThoughtworksXstreamIoXmlSaxWriter))
#define ComThoughtworksXstreamIoXmlSaxWriter_

#define RESTRICT_ComThoughtworksXstreamIoXmlAbstractXmlWriter 1
#define INCLUDE_ComThoughtworksXstreamIoXmlAbstractXmlWriter 1
#include "com/thoughtworks/xstream/io/xml/AbstractXmlWriter.h"

#define RESTRICT_OrgXmlSaxXMLReader 1
#define INCLUDE_OrgXmlSaxXMLReader 1
#include "org/xml/sax/XMLReader.h"

@class ComThoughtworksXstreamIoXmlXmlFriendlyReplacer;
@class OrgXmlSaxInputSource;
@protocol ComThoughtworksXstreamIoNamingNameCoder;
@protocol OrgXmlSaxContentHandler;
@protocol OrgXmlSaxDTDHandler;
@protocol OrgXmlSaxEntityResolver;
@protocol OrgXmlSaxErrorHandler;

/*!
 @brief A SAX <code>parser</code> that acts as an XStream 
 <code>com.thoughtworks.xstream.io.HierarchicalStreamWriter</code> to enable direct generation of a
  SAX event flow from the XStream serialization of a list of list of Java objects.
 <p>
  As a
  custom SAX parser, this class ignores the arguments of the two standard parse methods (<code>parse(java.lang.String)</code>
  and <code>parse(org.xml.sax.InputSource)</code>) but relies on a proprietary SAX property 
 <code>SOURCE_OBJECT_LIST_PROPERTY</code> to define the list of objects to serialize. 
 </p>
  <p>
  Configuration of this SAX parser is achieved through the standard 
 <code>property mechanism</code>. While specific setter methods require direct
  access to the parser instance, SAX properties support configuration settings to be propagated
  through a chain of <code>filters</code> down to the underlying parser
  object. 
 </p>
  <p>
  This mechanism shall be used to configure the 
 <code>to be serialized</code> as well as the 
 <code>facade</code>.
  </p>
 @author Laurent Bihanic
 */
@interface ComThoughtworksXstreamIoXmlSaxWriter : ComThoughtworksXstreamIoXmlAbstractXmlWriter < OrgXmlSaxXMLReader >

#pragma mark Public

- (instancetype __nonnull)init;

- (instancetype __nonnull)initWithBoolean:(jboolean)includeEnclosingDocument;

/*!
 @since 1.4
 */
- (instancetype __nonnull)initWithBoolean:(jboolean)includeEnclosingDocument
withComThoughtworksXstreamIoNamingNameCoder:(id<ComThoughtworksXstreamIoNamingNameCoder>)nameCoder;

/*!
 */
- (instancetype __nonnull)initWithBoolean:(jboolean)includeEnclosingDocument
withComThoughtworksXstreamIoXmlXmlFriendlyReplacer:(ComThoughtworksXstreamIoXmlXmlFriendlyReplacer *)replacer;

/*!
 @since 1.4
 */
- (instancetype __nonnull)initWithComThoughtworksXstreamIoNamingNameCoder:(id<ComThoughtworksXstreamIoNamingNameCoder>)nameCoder;

/*!
 */
- (instancetype __nonnull)initWithComThoughtworksXstreamIoXmlXmlFriendlyReplacer:(ComThoughtworksXstreamIoXmlXmlFriendlyReplacer *)replacer;

- (void)addAttributeWithNSString:(NSString *)name
                    withNSString:(NSString *)value;

- (void)close;

- (void)endNode;

- (void)flush;

/*!
 @brief Returns the current content handler.
 @return the current content handler, or <code>null</code> if none
          has been registered.
 - seealso: #setContentHandler
 */
- (id<OrgXmlSaxContentHandler>)getContentHandler;

/*!
 @brief Returns the current DTD handler.
 @return the current DTD handler, or <code>null</code> if none
          has been registered.
 - seealso: #setDTDHandler
 */
- (id<OrgXmlSaxDTDHandler>)getDTDHandler;

/*!
 @brief Returns the current entity resolver.
 @return the current entity resolver, or <code>null</code> if none
          has been registered.
 - seealso: #setEntityResolver
 */
- (id<OrgXmlSaxEntityResolver>)getEntityResolver;

/*!
 @brief Returns the current error handler.
 @return the current error handler, or <code>null</code> if none
          has been registered.
 - seealso: #setErrorHandler
 */
- (id<OrgXmlSaxErrorHandler>)getErrorHandler;

/*!
 @brief Looks up the value of a feature.
 <p>
  The feature name is any fully-qualified URI.  It is
  possible for an XMLReader to recognize a feature name but
  to be unable to return its value; this is especially true
  in the case of an adapter for a SAX1 Parser, which has
  no way of knowing whether the underlying parser is
  performing validation or expanding external entities.</p>
  <p>
  All XMLReaders are required to recognize the 
 <code>http://xml.org/sax/features/namespaces</code> and the 
 <code>http://xml.org/sax/features/namespace-prefixes</code> feature
  names.</p>
  <p>
  Some feature values may be available only in specific
  contexts, such as before, during, or after a parse.</p>
  <p>
  Implementors are free (and encouraged) to invent their own
  features, using names built on their own URIs.</p>
 @param name the feature name, which is a fully-qualified URI.
 @return the current state of the feature (true or false).
 @throw SAXNotRecognizedExceptionwhen the XMLReader does not
                                    recognize the feature name.
 - seealso: #setFeature
 */
- (jboolean)getFeatureWithNSString:(NSString *)name;

/*!
 @brief Looks up the value of a property.
 <p>
  The property name is any fully-qualified URI.  It is
  possible for an XMLReader to recognize a property name but
  to be unable to return its state.</p>
  <p>
  XMLReaders are not required to recognize any specific
  property names, though an initial core set is documented for
  SAX2.</p>
  <p>
  Some property values may be available only in specific
  contexts, such as before, during, or after a parse.</p>
  <p>
  Implementors are free (and encouraged) to invent their own properties,
  using names built on their own URIs.</p>
 @param name the property name, which is a fully-qualified URI.
 @return the current value of the property.
 @throw SAXNotRecognizedExceptionwhen the XMLReader does not
                                    recognize the property name.
 - seealso: #getProperty
 */
- (id)getPropertyWithNSString:(NSString *)name;

/*!
 @brief Parse an XML document.
 <p>
  The application can use this method to instruct the XML
  reader to begin parsing an XML document from any valid input
  source (a character stream, a byte stream, or a URI).</p>
  <p>
  Applications may not invoke this method while a parse is in
  progress (they should create a new XMLReader instead for each
  nested XML document).  Once a parse is complete, an
  application may reuse the same XMLReader object, possibly
  with a different input source.</p>
  <p>
  During the parse, the XMLReader will provide information
  about the XML document through the registered event
  handlers.</p>
  <p>
  This method is synchronous: it will not return until parsing
  has ended.  If a client application wants to terminate
  parsing early, it should throw an exception.</p>
  <p>
  <strong>Note</strong>: As a custom SAX parser, this class
  ignores the <code>source</code> argument of this method
  and relies on the proprietary SAX property 
 <code>SOURCE_OBJECT_LIST_PROPERTY</code>) to define the list of
  objects to serialize.</p>
 @param input The input source for the top-level of the               XML document.
 @throw SAXExceptionAny SAX exception, possibly wrapping
                       another exception.
 - seealso: org.xml.sax.InputSource
 - seealso: #parse(java.lang.String)
 - seealso: #setEntityResolver
 - seealso: #setDTDHandler
 - seealso: #setContentHandler
 - seealso: #setErrorHandler
 */
- (void)parseWithOrgXmlSaxInputSource:(OrgXmlSaxInputSource *)input;

/*!
 @brief Parses an XML document from a system identifier (URI).
 <p>
  This method is a shortcut for the common case of reading a
  document from a system identifier.  It is the exact
  equivalent of the following:</p>
  <blockquote>
  @code

     parse(new InputSource(systemId));  
  
@endcode
  </blockquote>
  <p>
  If the system identifier is a URL, it must be fully resolved
  by the application before it is passed to the parser.</p>
  <p>
  <strong>Note</strong>: As a custom SAX parser, this class
  ignores the <code>systemId</code> argument of this method
  and relies on the proprietary SAX property 
 <code>SOURCE_OBJECT_LIST_PROPERTY</code>) to define the list of
  objects to serialize.</p>
 @param systemId the system identifier (URI).
 @throw SAXExceptionAny SAX exception, possibly wrapping
                       another exception.
 - seealso: #parse(org.xml.sax.InputSource)
 */
- (void)parseWithNSString:(NSString *)systemId;

/*!
 @brief Allows an application to register a content event handler.
 <p>
  If the application does not register a content handler, all
  content events reported by the SAX parser will be silently
  ignored.</p>
  <p>
  Applications may register a new or different handler in the
  middle of a parse, and the SAX parser must begin using the new
  handler immediately.</p>
 @param handler the content handler.
 @throw NullPointerExceptionif the handler argument is
                               <code>null</code>.
 - seealso: #getContentHandler
 */
- (void)setContentHandlerWithOrgXmlSaxContentHandler:(id<OrgXmlSaxContentHandler>)handler;

/*!
 @brief Allows an application to register a DTD event handler.
 <p>
  If the application does not register a DTD handler, all DTD
  events reported by the SAX parser will be silently ignored.</p>
  <p>
  Applications may register a new or different handler in the
  middle of a parse, and the SAX parser must begin using the new
  handler immediately.</p>
 @param handler the DTD handler.
 @throw NullPointerExceptionif the handler argument is
                               <code>null</code>.
 - seealso: #getDTDHandler
 */
- (void)setDTDHandlerWithOrgXmlSaxDTDHandler:(id<OrgXmlSaxDTDHandler>)handler;

/*!
 @brief Allows an application to register an entity resolver.
 <p>
  If the application does not register an entity resolver,
  the XMLReader will perform its own default resolution.</p>
  <p>
  Applications may register a new or different resolver in the
  middle of a parse, and the SAX parser must begin using the new
  resolver immediately.</p>
 @param resolver the entity resolver.
 @throw NullPointerExceptionif the resolver argument is
                               <code>null</code>.
 - seealso: #getEntityResolver
 */
- (void)setEntityResolverWithOrgXmlSaxEntityResolver:(id<OrgXmlSaxEntityResolver>)resolver;

/*!
 @brief Allows an application to register an error event handler.
 <p>
  If the application does not register an error handler, all
  error events reported by the SAX parser will be silently
  ignored; however, normal processing may not continue.  It is
  highly recommended that all SAX applications implement an
  error handler to avoid unexpected bugs.</p>
  <p>
  Applications may register a new or different handler in the
  middle of a parse, and the SAX parser must begin using the new
  handler immediately.</p>
 @param handler the error handler.
 @throw NullPointerExceptionif the handler argument is
                               <code>null</code>.
 - seealso: #getErrorHandler
 */
- (void)setErrorHandlerWithOrgXmlSaxErrorHandler:(id<OrgXmlSaxErrorHandler>)handler;

/*!
 @brief Sets the state of a feature.
 <p>
  The feature name is any fully-qualified URI.</p>
  <p>
  All XMLReaders are required to support setting 
 <code>http://xml.org/sax/features/namespaces</code> to 
 <code>true</code> and 
 <code>http://xml.org/sax/features/namespace-prefixes</code> to 
 <code>false</code>.</p>
  <p>
  Some feature values may be immutable or mutable only
  in specific contexts, such as before, during, or after
  a parse.</p>
  <p>
  <strong>Note</strong>: This implementation only supports the two
  mandatory SAX features.</p>
 @param name the feature name, which is a fully-qualified URI.
 @param value the requested state of the feature (true or false).
 @throw SAXNotRecognizedExceptionwhen the XMLReader does not
                                    recognize the feature name.
 - seealso: #getFeature
 */
- (void)setFeatureWithNSString:(NSString *)name
                   withBoolean:(jboolean)value;

/*!
 @brief Sets the value of a property.
 <p>
  The property name is any fully-qualified URI.  It is
  possible for an XMLReader to recognize a property name but
  to be unable to set its value.</p>
  <p>
  XMLReaders are not required to recognize setting any
  specific property names, though a core set is provided with
  SAX2.</p>
  <p>
  Some property values may be immutable or mutable only
  in specific contexts, such as before, during, or after
  a parse.</p>
  <p>
  This method is also the standard mechanism for setting
  extended handlers.</p>
  <p>
  <strong>Note</strong>: This implementation only supports two
  (proprietary) properties: <code>CONFIGURED_XSTREAM_PROPERTY</code>
  and <code>SOURCE_OBJECT_LIST_PROPERTY</code>.</p>
 @param name the property name, which is a fully-qualified URI.
 @param value the requested value for the property.
 @throw SAXNotRecognizedExceptionwhen the XMLReader does not
                                    recognize the property name.
 @throw SAXNotSupportedExceptionwhen the XMLReader recognizes
                                    the property name but cannot set
                                    the requested value.
 - seealso: #getProperty
 */
- (void)setPropertyWithNSString:(NSString *)name
                         withId:(id)value;

- (void)setValueWithNSString:(NSString *)text;

- (void)startNodeWithNSString:(NSString *)name;

@end

J2OBJC_EMPTY_STATIC_INIT(ComThoughtworksXstreamIoXmlSaxWriter)

/*!
 @brief The <code>property</code> to configure the XStream
  facade to be used for object serialization.If the property
  is not set, a new XStream facade will be allocated for each
  parse.
 */
inline NSString *ComThoughtworksXstreamIoXmlSaxWriter_get_CONFIGURED_XSTREAM_PROPERTY(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComThoughtworksXstreamIoXmlSaxWriter_CONFIGURED_XSTREAM_PROPERTY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComThoughtworksXstreamIoXmlSaxWriter, CONFIGURED_XSTREAM_PROPERTY, NSString *)

/*!
 @brief The <code>property</code> to configure the list of
  Java objects to serialize.Setting this property prior
  invoking one of the parse() methods is mandatory.
 - seealso: #parse(java.lang.String)
 - seealso: #parse(org.xml.sax.InputSource)
 */
inline NSString *ComThoughtworksXstreamIoXmlSaxWriter_get_SOURCE_OBJECT_LIST_PROPERTY(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComThoughtworksXstreamIoXmlSaxWriter_SOURCE_OBJECT_LIST_PROPERTY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComThoughtworksXstreamIoXmlSaxWriter, SOURCE_OBJECT_LIST_PROPERTY, NSString *)

FOUNDATION_EXPORT void ComThoughtworksXstreamIoXmlSaxWriter_initWithComThoughtworksXstreamIoNamingNameCoder_(ComThoughtworksXstreamIoXmlSaxWriter *self, id<ComThoughtworksXstreamIoNamingNameCoder> nameCoder);

FOUNDATION_EXPORT ComThoughtworksXstreamIoXmlSaxWriter *new_ComThoughtworksXstreamIoXmlSaxWriter_initWithComThoughtworksXstreamIoNamingNameCoder_(id<ComThoughtworksXstreamIoNamingNameCoder> nameCoder) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComThoughtworksXstreamIoXmlSaxWriter *create_ComThoughtworksXstreamIoXmlSaxWriter_initWithComThoughtworksXstreamIoNamingNameCoder_(id<ComThoughtworksXstreamIoNamingNameCoder> nameCoder);

FOUNDATION_EXPORT void ComThoughtworksXstreamIoXmlSaxWriter_initWithBoolean_withComThoughtworksXstreamIoNamingNameCoder_(ComThoughtworksXstreamIoXmlSaxWriter *self, jboolean includeEnclosingDocument, id<ComThoughtworksXstreamIoNamingNameCoder> nameCoder);

FOUNDATION_EXPORT ComThoughtworksXstreamIoXmlSaxWriter *new_ComThoughtworksXstreamIoXmlSaxWriter_initWithBoolean_withComThoughtworksXstreamIoNamingNameCoder_(jboolean includeEnclosingDocument, id<ComThoughtworksXstreamIoNamingNameCoder> nameCoder) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComThoughtworksXstreamIoXmlSaxWriter *create_ComThoughtworksXstreamIoXmlSaxWriter_initWithBoolean_withComThoughtworksXstreamIoNamingNameCoder_(jboolean includeEnclosingDocument, id<ComThoughtworksXstreamIoNamingNameCoder> nameCoder);

FOUNDATION_EXPORT void ComThoughtworksXstreamIoXmlSaxWriter_initWithComThoughtworksXstreamIoXmlXmlFriendlyReplacer_(ComThoughtworksXstreamIoXmlSaxWriter *self, ComThoughtworksXstreamIoXmlXmlFriendlyReplacer *replacer);

FOUNDATION_EXPORT ComThoughtworksXstreamIoXmlSaxWriter *new_ComThoughtworksXstreamIoXmlSaxWriter_initWithComThoughtworksXstreamIoXmlXmlFriendlyReplacer_(ComThoughtworksXstreamIoXmlXmlFriendlyReplacer *replacer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComThoughtworksXstreamIoXmlSaxWriter *create_ComThoughtworksXstreamIoXmlSaxWriter_initWithComThoughtworksXstreamIoXmlXmlFriendlyReplacer_(ComThoughtworksXstreamIoXmlXmlFriendlyReplacer *replacer);

FOUNDATION_EXPORT void ComThoughtworksXstreamIoXmlSaxWriter_initWithBoolean_withComThoughtworksXstreamIoXmlXmlFriendlyReplacer_(ComThoughtworksXstreamIoXmlSaxWriter *self, jboolean includeEnclosingDocument, ComThoughtworksXstreamIoXmlXmlFriendlyReplacer *replacer);

FOUNDATION_EXPORT ComThoughtworksXstreamIoXmlSaxWriter *new_ComThoughtworksXstreamIoXmlSaxWriter_initWithBoolean_withComThoughtworksXstreamIoXmlXmlFriendlyReplacer_(jboolean includeEnclosingDocument, ComThoughtworksXstreamIoXmlXmlFriendlyReplacer *replacer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComThoughtworksXstreamIoXmlSaxWriter *create_ComThoughtworksXstreamIoXmlSaxWriter_initWithBoolean_withComThoughtworksXstreamIoXmlXmlFriendlyReplacer_(jboolean includeEnclosingDocument, ComThoughtworksXstreamIoXmlXmlFriendlyReplacer *replacer);

FOUNDATION_EXPORT void ComThoughtworksXstreamIoXmlSaxWriter_initWithBoolean_(ComThoughtworksXstreamIoXmlSaxWriter *self, jboolean includeEnclosingDocument);

FOUNDATION_EXPORT ComThoughtworksXstreamIoXmlSaxWriter *new_ComThoughtworksXstreamIoXmlSaxWriter_initWithBoolean_(jboolean includeEnclosingDocument) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComThoughtworksXstreamIoXmlSaxWriter *create_ComThoughtworksXstreamIoXmlSaxWriter_initWithBoolean_(jboolean includeEnclosingDocument);

FOUNDATION_EXPORT void ComThoughtworksXstreamIoXmlSaxWriter_init(ComThoughtworksXstreamIoXmlSaxWriter *self);

FOUNDATION_EXPORT ComThoughtworksXstreamIoXmlSaxWriter *new_ComThoughtworksXstreamIoXmlSaxWriter_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComThoughtworksXstreamIoXmlSaxWriter *create_ComThoughtworksXstreamIoXmlSaxWriter_init(void);

J2OBJC_TYPE_LITERAL_HEADER(ComThoughtworksXstreamIoXmlSaxWriter)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_ComThoughtworksXstreamIoXmlSaxWriter")
