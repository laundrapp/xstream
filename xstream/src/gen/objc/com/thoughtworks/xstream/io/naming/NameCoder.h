//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Salton/Documents/Projects/xstream/xstream/src/java/com/thoughtworks/xstream/io/naming/NameCoder.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComThoughtworksXstreamIoNamingNameCoder")
#ifdef RESTRICT_ComThoughtworksXstreamIoNamingNameCoder
#define INCLUDE_ALL_ComThoughtworksXstreamIoNamingNameCoder 0
#else
#define INCLUDE_ALL_ComThoughtworksXstreamIoNamingNameCoder 1
#endif
#undef RESTRICT_ComThoughtworksXstreamIoNamingNameCoder

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComThoughtworksXstreamIoNamingNameCoder_) && (INCLUDE_ALL_ComThoughtworksXstreamIoNamingNameCoder || defined(INCLUDE_ComThoughtworksXstreamIoNamingNameCoder))
#define ComThoughtworksXstreamIoNamingNameCoder_

/*!
 @brief Coder between names in the object graph and names of a target format.
 <p>
  The names form the object graph are typically names generated from Java identifiers (Java
  types or field members), but some names may also contain a minus sign. However, the original
  name might have already been aliased, so a wider range of characters can occur. 
 </p>
  <p>
  The target names should satisfy the syntax of the target format. Transforming Java objects to
  XML this affects names that contain or even start with a dollar sign. Such names violate the
  XML specification. 
 </p>
  <p>
  By default all names from the object graph are used as node names in the target format.
  Meta-data that is necessary to unmarshal the object again is typically written as attribute.
  Since such attributes might be represented differently in the target format, the NameCoder
  distinguishes between the names used for meta-data elements and the ones for the object data.
  The names in the target format might even have to follow a different syntax. Remember, that
  XStream can be easily configured to write also object data as attributes. 
 </p>
  <p>
  Note that the instance of a NameCoder should be either thread-safe or implement <code>Cloneable</code>.
  </p>
 @author J&ouml;rg Schaible
 @since 1.4
 */
@protocol ComThoughtworksXstreamIoNamingNameCoder < JavaObject >

/*!
 @brief Encode an object name for a node in the target format.
 @param name the name of the object data
 @return the node name in the target format
 @since 1.4
 */
- (NSString *)encodeNodeWithNSString:(NSString *)name;

/*!
 @brief Encode a meta-data name for an attribute in the target format.
 @param name the name of the meta-data
 @return the attribute name in the target format
 @since 1.4
 */
- (NSString *)encodeAttributeWithNSString:(NSString *)name;

/*!
 @brief Decode a node name to an object name.
 @param nodeName the name of the node
 @return the name of the object
 @since 1.4
 */
- (NSString *)decodeNodeWithNSString:(NSString *)nodeName;

/*!
 @brief Decode an attribute name to an object name.
 @param attributeName the name of the attribute
 @return the name of the meta-data
 @since 1.4
 */
- (NSString *)decodeAttributeWithNSString:(NSString *)attributeName;

@end

J2OBJC_EMPTY_STATIC_INIT(ComThoughtworksXstreamIoNamingNameCoder)

J2OBJC_TYPE_LITERAL_HEADER(ComThoughtworksXstreamIoNamingNameCoder)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_ComThoughtworksXstreamIoNamingNameCoder")
